import tkinter as tk
from tkinter import ttk

class InputCopyTool:
    def __init__(self, root):
        self.root = root
        self.entry_info = []  # 存储输入框、默认值、是否为默认状态
        self.init_ui()

    def append_selected_value(self, combobox, entry, row_type):
        """下拉选择处理：根据行类型决定追加/替换内容"""
        selected = combobox.get()
        if not selected:
            return
        current_text = entry.get().strip()
        # 处理默认值：无论追加/替换，默认值状态下都直接用选中值
        for info in self.entry_info:
            ent, dv, is_default = info
            if ent == entry and is_default:
                new_text = selected
                entry.config(fg="#000000")
                info[2] = False
                break
        else:
            # 核心逻辑：row_type=1 追加，row_type=2 替换
            if row_type == 1:  # 追加模式（1、6、7行）
                new_text = f"{current_text}, {selected}" if current_text else selected
            else:  # 替换模式（3、4、5行）
                new_text = selected  # 直接覆盖当前内容
        entry.delete(0, tk.END)
        entry.insert(0, new_text)

    def init_ui(self):
        self.root.title("信息录入+下拉选择工具")
        self.root.geometry("950x400")
        self.root.attributes("-topmost", True)

        # 定义所有输入项：新增row_type（1=追加，2=替换，0=无下拉）
        # 下拉选项通过sorted按字符串长度排序：key=lambda x: len(x)
        items = [
            # 1行：物品类别（追加模式，下拉按长度排序）
            ("1，物品类别", True, "", 
             sorted([
                "地锁", "防撞桶", "警示柱", "水马", "三角牌", "锥桶", "充电桩", "施工牌", "纸箱", "轮胎",
                "垃圾桶", "石墩", "圆柱", "方柱", "充电线", "消防栓", "限宽墩", "细杆", "井盖", "地面特殊图案",
                "镂空格栅地面", "电线杆", "警示标志立牌", "路灯", "花盆", "雕像", "布匹或塑料袋", "岗亭", "指示牌",
                "防水袋", "马路大石头", "三脚架", "桌子", "近处curb(仅限自车附近)", "椅子", "行李箱", "手推车",
                "灭火器", "铁架子", "动物", "假人", "消防箱", "水桶", "可移动离散栅栏", "木头片", "伞（收起）",
                "塑料箱", "其他", "近距离小孩", "一堆管子", "小路桩", "石头堆", "摊位", "气球", "车体突出物体", "翻了的车"
             ], key=lambda x: len(x)), 1),
            
            ("2，物品方位", False, "", None, 0),  # 禁用输入框，无下拉
            
            # 3行：场景（替换模式，下拉按长度排序）
            ("3，场景", True, "城市宽阔道路", 
             sorted(["高速", "城市宽阔道路", "单车道道路", "乡村/城中村道路", "地下车库", "地面停车场", "园区", "施工", "加油站", "隧道"],
                    key=lambda x: len(x)), 2),
            
            # 4行：天气（替换模式，下拉按长度排序）
            ("4，天气", True, "晴天", 
             sorted(["晴天", "阴天", "夜晚（路面光线充足）", "夜晚（光线昏暗）", "小雨", "大雨", "小雪", "大雪", "冰雹", "地库", "雾天", "夜晚雨天"],
                    key=lambda x: len(x)), 2),
            
            # 5行：路面情况（替换模式，下拉按长度排序）
            ("5，路面情况", True, "路面良好", 
             sorted(["路面良好", "山路", "土路", "坑洼", "覆水", "水坑", "覆雪", "雪堆"],
                    key=lambda x: len(x)), 2),
            
            # 6行：质量问题（追加模式，下拉按长度排序）
            ("6，质量问题", True, "无", 
             sorted([
                "物体反投缺失", "物体反投过大", "路面重建不对", "物体反投偏移", "照片存在绿边", "lider_cover_region为空",
                "lider_cover_region残缺", "照片闪现灰图", "地面存在点状空洞", "少量帧照片缺失", "动目标框漂移",
                "镜头被遮挡", "照片异常", "语义/高度缺失", "车体上存在突出物体", "错误返投实际不存在的物体"
             ], key=lambda x: len(x)), 1),
            
            # 7行：图片脏污（追加模式，下拉按长度排序）
            ("7，图片脏污", True, "无", 
             sorted(["cam脏污", "cam眩光", "cam遮挡"],
                    key=lambda x: len(x)), 1)
        ]

        # 循环生成UI组件
        for idx, (label_text, show_entry, default_val, combo_options, row_type) in enumerate(items):
            # 标签
            label = tk.Label(self.root, text=label_text, anchor="e", width=12, font=("Arial", 10))
            label.grid(row=idx, column=0, padx=(30, 10), pady=(15, 0))
            
            if show_entry:
                # 可输入的输入框
                entry = tk.Entry(self.root, width=40, font=("Arial", 10))
                entry.grid(row=idx, column=1, padx=(0, 10), pady=(15, 0))
                
                # 初始化默认值
                is_default = False
                if default_val:
                    entry.insert(0, default_val)
                    entry.config(fg="#999999")
                    is_default = True
                self.entry_info.append([entry, default_val, is_default])
                
                # 绑定聚焦/失焦事件
                entry.bind("<FocusIn>", lambda e, ent=entry, dv=default_val: self.on_focus(ent, dv))
                entry.bind("<FocusOut>", lambda e, ent=entry, dv=default_val: self.on_blur(ent, dv))
                
                # 有下拉选项则生成下拉框（传入行类型用于追加/替换判断）
                if combo_options:
                    combobox = ttk.Combobox(
                        self.root, values=combo_options, width=22, font=("Arial", 10), state="readonly"
                    )
                    combobox.config(height=8)  # 下拉框显示8个选项
                    combobox.grid(row=idx, column=2, padx=10, pady=(15, 0))
                    # 绑定下拉选择事件：携带row_type参数
                    combobox.bind(
                        "<<ComboboxSelected>>", 
                        lambda event, cb=combobox, ent=entry, rt=row_type: self.append_selected_value(cb, ent, rt)
                    )
            else:
                # 禁用的空输入框
                empty_entry = tk.Entry(self.root, width=40, font=("Arial", 10), state="disabled")
                empty_entry.grid(row=idx, column=1, padx=(0, 10), pady=(15, 0))

    def on_focus(self, entry, default_val):
        """输入框聚焦：清空默认值并变黑"""
        for info in self.entry_info:
            ent, dv, is_default = info
            if ent == entry and is_default:
                entry.delete(0, tk.END)
                entry.config(fg="#000000")
                info[2] = False
                break

    def on_blur(self, entry, default_val):
        """输入框失焦：无内容则恢复默认值并变灰"""
        val = entry.get().strip()
        if not val:
            entry.delete(0, tk.END)
            entry.insert(0, default_val)
            entry.config(fg="#999999")
            for info in self.entry_info:
                ent, dv, _ = info
                if ent == entry:
                    info[2] = True
                    break
        else:
            for info in self.entry_info:
                ent, _, _ = info
                if ent == entry:
                    info[2] = False
                    break

    def copy_and_clear(self):
        """复制所有内容到剪贴板，然后恢复初始状态"""
        filled_content = []
        for info in self.entry_info:
            entry, default_val, is_default = info
            val = entry.get().strip().replace('\n', '').replace('\r', '')
            filled_content.append(default_val if is_default else val)
        
        filled_content.insert(1, "")  # 第2位插入空行（对应物品方位）
        final_content = "\n".join(filled_content)
        
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(final_content)
            self.root.update()
            
            # 清空后恢复默认值
            for info in self.entry_info:
                entry, default_val, _ = info
                entry.delete(0, tk.END)
                if default_val:
                    entry.insert(0, default_val)
                    entry.config(fg="#999999")
                    info[2] = True
                else:
                    info[2] = False
        except:
            pass

if __name__ == "__main__":
    root = tk.Tk()
    tool = InputCopyTool(root)
    root.mainloop()
